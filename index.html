<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MARC 21 - Scroll & Edition Fix</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
:root { --primary: #0f172a; --accent: #2563eb; --bg: #f8fafc; --text: #334155; }
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding-bottom: 120px; }
header { background: white; padding: 16px; font-weight: 800; text-align: center; border-bottom: 1px solid #e2e8f0; position: sticky; top: 0; z-index: 50; }

/* Controls */
.controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; padding: 10px; background: white; border-bottom: 1px solid #e2e8f0; }
.mode-btn { padding: 8px; border: 1px solid #cbd5e1; border-radius: 8px; background: white; font-size: 13px; color: #64748b; font-weight: 600; transition: all 0.2s; }
.mode-btn.active { background: var(--accent); color: white; border-color: var(--accent); box-shadow: 0 2px 4px rgba(37,99,235,0.3); }

/* Camera */
.scan-area { padding: 16px; text-align: center; }
#scanBtn { width: 100%; padding: 16px; background: var(--primary); color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); }
#scanBtn:active { transform: scale(0.98); }
.status { margin-top: 8px; font-size: 13px; color: #64748b; min-height: 20px; }

/* MARC Card */
.card { background: white; margin: 10px 16px; padding: 16px; border-radius: 12px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.card-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.badge { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: bold; background: #f1f5f9; color: #64748b; }
.badge.api { background: #dcfce7; color: #166534; }
.badge.ocr { background: #ffedd5; color: #9a3412; }

/* Input Fields with Horizontal Scroll */
.field-group { margin-bottom: 14px; }
.label-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
.tag-label { font-family: monospace; font-size: 12px; font-weight: bold; color: #94a3b8; }

.input-wrapper { display: flex; border: 1px solid #cbd5e1; border-radius: 8px; overflow: hidden; background: #fff; }

/* é—œéµä¿®æ”¹ï¼šä½¿ç”¨ textarea æ¨¡æ“¬å–®è¡Œä¸¦å…è¨±å·¦å³æ»‘å‹• */
.scroll-input {
    flex: 1; 
    padding: 12px; 
    font-size: 16px; 
    font-family: monospace; 
    border: none; 
    outline: none;
    
    /* æ»‘å‹•è¨­å®š */
    white-space: nowrap;  /* å¼·åˆ¶ä¸æ›è¡Œ */
    overflow-x: auto;     /* å…è¨±æ°´å¹³æ²å‹• */
    overflow-y: hidden;   /* éš±è—å‚ç›´æ²å‹• */
    resize: none;         /* ç¦æ­¢æ‹‰å¤§ */
    line-height: 1.5;
}

/* å°åº•æ‘˜è¦ä¾‹å¤–ï¼šå…è¨±å¤šè¡Œ */
.multiline { white-space: normal; min-height: 80px; }

.copy-btn {
    width: 44px; background: #f8fafc; border-left: 1px solid #cbd5e1; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;
}
.copy-btn:active { background: #e2e8f0; }

/* Copy All FAB */
.fab-container { position: fixed; bottom: 20px; left: 0; right: 0; padding: 0 16px; z-index: 100; pointer-events: none; }
.copy-all-btn {
    pointer-events: auto; width: 100%; padding: 14px; background: #059669; color: white; border: none; border-radius: 50px; font-size: 16px; font-weight: bold; box-shadow: 0 4px 12px rgba(5,150,105,0.3); display: flex; align-items: center; justify-content: center; gap: 8px;
}
.copy-all-btn:active { transform: translateY(2px); }

.updated { animation: flash 1s ease-out; border: 1px solid #22c55e !important; background: #f0fdf4; }
@keyframes flash { 0% { background: #dcfce7; } 100% { background: white; } }

details { margin: 16px; font-size: 12px; color: #94a3b8; }
#debug { white-space: pre-wrap; background: #f1f5f9; padding: 10px; border-radius: 8px; border: 1px solid #e2e8f0; overflow-x: auto; max-height: 200px; }
</style>
</head>
<body>

<header>MARC 21 - v6.0</header>

<div class="controls">
    <button class="mode-btn active" onclick="setMode('copyright')">æ¢ç¢¼/ç‰ˆæ¬Š</button>
    <button class="mode-btn" onclick="setMode('cover')">å°é¢ (åˆä½µ)</button>
    <button class="mode-btn" onclick="setMode('back')">å°åº•æ‘˜è¦</button>
</div>

<div class="scan-area">
    <button id="scanBtn" onclick="document.getElementById('fileIn').click()">ğŸ“¸ å•Ÿå‹•ç›¸æ©Ÿ</button>
    <div class="status" id="status">æº–å‚™å°±ç·’</div>
    <input type="file" id="fileIn" accept="image/*" capture="environment" style="display:none" onchange="process(this)">
</div>

<div class="card">
    <div class="card-head">
        <b>MARC ç·¨è¼¯å€</b>
        <span id="srcTag" class="badge">ç„¡è³‡æ–™</span>
    </div>
    
    <div class="field-group">
        <div class="label-row"><span class="tag-label">020 ISBN</span></div>
        <div class="input-wrapper">
            <textarea id="f020" class="scroll-input" rows="1" placeholder="$a"></textarea>
            <button class="copy-btn" onclick="copyOne('f020')">ğŸ“‹</button>
        </div>
    </div>
    <div class="field-group">
        <div class="label-row"><span class="tag-label">100 Author</span></div>
        <div class="input-wrapper">
            <textarea id="f100" class="scroll-input" rows="1" placeholder="$a Name, $e author."></textarea>
            <button class="copy-btn" onclick="copyOne('f100')">ğŸ“‹</button>
        </div>
    </div>
    <div class="field-group">
        <div class="label-row"><span class="tag-label">245 Title (å¯å·¦å³æ»‘å‹•)</span></div>
        <div class="input-wrapper">
            <textarea id="f245" class="scroll-input" rows="1" placeholder="$a Title : $b Sub"></textarea>
            <button class="copy-btn" onclick="copyOne('f245')">ğŸ“‹</button>
        </div>
    </div>
    <div class="field-group">
        <div class="label-row"><span class="tag-label">250 Edition (å¢å¼·åµæ¸¬)</span></div>
        <div class="input-wrapper">
            <textarea id="f250" class="scroll-input" rows="1" placeholder="$a"></textarea>
            <button class="copy-btn" onclick="copyOne('f250')">ğŸ“‹</button>
        </div>
    </div>
    <div class="field-group">
        <div class="label-row"><span class="tag-label">264 Pub</span></div>
        <div class="input-wrapper">
            <textarea id="f264" class="scroll-input" rows="1" placeholder="$b Pub, $c Year"></textarea>
            <button class="copy-btn" onclick="copyOne('f264')">ğŸ“‹</button>
        </div>
    </div>
    <div class="field-group">
        <div class="label-row"><span class="tag-label">520 Abstract</span></div>
        <div class="input-wrapper">
            <textarea id="f520" class="scroll-input multiline" placeholder="$a"></textarea>
            <button class="copy-btn" onclick="copyOne('f520')">ğŸ“‹</button>
        </div>
    </div>
</div>

<details>
    <summary>OCR åŸå§‹æ–‡å­—</summary>
    <div id="debug"></div>
</details>
<canvas id="cvs" style="display:none"></canvas>

<div class="fab-container">
    <button class="copy-all-btn" onclick="copyAll()">ğŸ“‹ è¤‡è£½å®Œæ•´è¨˜éŒ„</button>
</div>

<script>
let worker, mode = 'copyright';

(async () => {
    msg('è¼‰å…¥ OCR å¼•æ“...', true);
    worker = await Tesseract.createWorker('eng+fra+deu+spa+rus');
    msg('ç³»çµ±å°±ç·’');
})();

function setMode(m) {
    mode = m;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    msg(m === 'cover' ? 'å°é¢æ¨¡å¼ï¼šè£œå®Œæ¨™é¡Œèˆ‡ç‰ˆæ¬¡' : m === 'copyright' ? 'ç‰ˆæ¬Šæ¨¡å¼ï¼šè£œå®Œå‡ºç‰ˆç¤¾' : 'å°åº•æ¨¡å¼ï¼šæŠ“å–æ‘˜è¦');
}

async function process(input) {
    if (!input.files[0]) return;
    const file = input.files[0];
    msg('å½±åƒå„ªåŒ–è™•ç†...', true);
    const imgData = await preprocess(file);
    msg('OCR è­˜åˆ¥ä¸­...', true);
    const { data } = await worker.recognize(imgData);
    document.getElementById('debug').textContent = data.text;
    await analyze(data);
    input.value = '';
}

async function analyze(data) {
    const text = data.text;
    const lines = data.lines;

    // æ¸…æ´— ISBN
    const clean = text.replace(/\|/g,'1').replace(/\bO(\d)/g,'0$1').replace(/[-\s]/g,'');
    const isbnMatch = clean.match(/(97[89]\d{10})|(\d{9}[\dX])/);
    let apiSuccess = false;

    // 1. API æŸ¥è©¢
    if (isbnMatch) {
        const isbn = isbnMatch[0];
        if(!val('f020')) updateField('f020', `$a ${isbn}`);
        msg(`API æŸ¥è©¢: ${isbn}...`, true);
        
        apiSuccess = await fetchGoogle(isbn);
        if (!apiSuccess) apiSuccess = await fetchOpenLibrary(isbn); // ç°¡åŒ–é‚è¼¯ï¼ŒåŒå‰
        if (!apiSuccess) apiSuccess = await fetchBnF(isbn);         // ç°¡åŒ–é‚è¼¯ï¼ŒåŒå‰
    }

    // 2. OCR è£œå¼·
    msg('OCR åˆ†æä¸­...');
    
    // å…¨åŸŸç‰ˆæ¬¡åµæ¸¬ (ç„¡è«–ä»€éº¼æ¨¡å¼éƒ½è·‘ä¸€æ¬¡ï¼Œå› ç‚ºç‰ˆæ¬¡å¾ˆé‡è¦)
    const edition = extractEdition(text);
    if (edition) updateField('f250', `$a ${edition}`, true); // Force update specifically for edition

    if (mode === 'cover') {
        analyzeCoverMerge(lines);
    } else if (mode === 'copyright') {
        analyzeCopyrightMerge(text, lines);
    } else if (mode === 'back') {
        analyzeBack(lines);
    }

    if (apiSuccess) {
        document.getElementById('srcTag').textContent = 'API + OCR';
        document.getElementById('srcTag').className = 'badge api';
    } else {
        document.getElementById('srcTag').textContent = 'OCR è§£æ';
        document.getElementById('srcTag').className = 'badge ocr';
    }
    msg('å®Œæˆ');
}

// --- é—œéµå‡ç´šï¼šç‰ˆæ¬¡è­˜åˆ¥ Regex ---
function extractEdition(text) {
    // ç§»é™¤è®ŠéŸ³ç¬¦è™Ÿä¸¦è½‰å°å¯«ï¼Œæ–¹ä¾¿æ¯”å° (Ã© -> e)
    const norm = text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
    
    // 1. é‡å°è¥¿ç­ç‰™æ–‡/è‘¡è„ç‰™æ–‡çš„åºæ•¸ (7Âª, 3Âº, 2.Âª)
    // 2. é‡å°æ³•æ–‡/è‹±æ–‡ (3e, 3rd, 3Ã¨me)
    // 3. é—œéµå­—: edicion, edition, auflage, edit
    
    // Regex è§£é‡‹ï¼š
    // (\d+[\.\s]?(Âª|Âº|a|o|st|nd|rd|th|e|eme|er|re)) -> æŠ“å– "7Âª", "3e", "1st"
    // \s* -> å…è¨±ä¸­é–“æœ‰ç©ºæ ¼
    // (ed|Ã©d|aufl) -> æŠ“å– edition çš„é–‹é ­
    
    const regexComplex = /(\d+[\.\s]?(Âª|Âº|a|o|st|nd|rd|th|e|eme|er|re))[\s\.]*(ed|Ã©d|aufl)/i;
    const match = norm.match(regexComplex);
    
    if (match) {
        // æ‰¾åˆ°åŸå§‹æ–‡å­—å°æ‡‰çš„ä½ç½®ï¼Œå› ç‚º norm æ˜¯å°å¯«ä¸”ç„¡é‡éŸ³ï¼Œæˆ‘å€‘éœ€è¦å›æ¨åŸå§‹æ–‡å­—
        // é€™è£¡åšç°¡å–®è™•ç†ï¼šç›´æ¥ç”¨ Regex åœ¨åŸå§‹ text ä¸Šå†è·‘ä¸€æ¬¡ (Case Insensitive)
        // æ³¨æ„ï¼šåŸå§‹æ–‡å­—åŒ…å«é‡éŸ³ï¼Œæ‰€ä»¥ Regex ç¨å¾®æ”¾å¯¬
        const rawRegex = /(\d+[\.\s]?(Âª|Âº|a|o|st|nd|rd|th|e|eme|er|re)).{0,10}(edici|Ã©diti|editi|aufla|Ã©d|ed)/i;
        const rawMatch = text.match(rawRegex);
        if (rawMatch) return rawMatch[0];
        
        // å¦‚æœåŸå§‹æŠ“ä¸åˆ° (å¯èƒ½å› ç‚ºé‡éŸ³ç¬¦è™Ÿå¹²æ“¾)ï¼Œäººå·¥çµ„å­—
        return `${match[1]} edition (Detected)`;
    }

    // é—œéµå­—è£œæ¼ (æ–‡å­—å‹ç‰ˆæ¬¡)
    const textEd = text.match(/(PremiÃ¨re|DeuxiÃ¨me|TroisiÃ¨me|First|Second|Third|Nueva)\s+(Ã©d|ed|aufl)/i);
    if(textEd) return textEd[0];

    return null;
}

function analyzeCoverMerge(lines) {
    if(!lines.length) return;
    const validLines = lines.filter(l => l.text.trim().length > 2);
    
    let maxH = 0;
    validLines.forEach(l => { const h = l.bbox.y1 - l.bbox.y0; if(h>maxH) maxH=h; });
    const titleLines = validLines.filter(l => (l.bbox.y1 - l.bbox.y0) > maxH * 0.7);
    const ocrTitle = titleLines.map(l => l.text.trim()).join(' ');
    
    // é¡Œååˆä½µé‚è¼¯
    const currentTitle = val('f245').replace(/^\$a /, '');
    if (currentTitle && ocrTitle.includes(currentTitle) && ocrTitle.length > currentTitle.length + 3) {
        const sub = ocrTitle.replace(currentTitle, '').replace(/^[:\s]+/, '').trim();
        if (sub) updateField('f245', `$a ${currentTitle} : $b ${sub}`, true);
    } else if (!currentTitle && ocrTitle) {
        updateField('f245', `$a ${ocrTitle}`);
    }
    
    // ä½œè€…åµæ¸¬
    if(titleLines.length > 0) {
        const topY = titleLines[0].bbox.y0;
        const authorLines = validLines.filter(l => l.bbox.y1 < topY && !/\d/.test(l.text));
        if(authorLines.length > 0 && !val('f100')) {
            updateField('f100', `$a ${formatAuthorName(authorLines[authorLines.length-1].text.trim())}, $e author.`);
        }
    }
}

function analyzeCopyrightMerge(text, lines) {
    // å¹´ä»½èˆ‡å‡ºç‰ˆç¤¾åµæ¸¬
    const yearMatch = text.match(/\b(19|20)\d{2}\b/);
    let pub = '';
    
    for(let l of lines) {
        const t = l.text;
        if(t.includes('Â©') || /Editions|Press|Verlag|Books/i.test(t)) {
            pub = t.replace(/.*Â©\s*\d*\s*/, '').replace(/^\d{4}/,'').trim();
            if(pub.length>2 && !/\d/.test(pub)) break; 
        }
    }
    
    const cur264 = val('f264');
    if(cur264.includes('$c') && !cur264.includes('$b') && pub) {
        updateField('f264', cur264.replace('$c', `: $b ${pub}, $c`), true);
    } else if(!cur264) {
        let s=''; if(pub) s+=`: $b ${pub}, `; if(yearMatch) s+=`$c ${yearMatch[0]}`;
        if(s) updateField('f264', `$a [Place] ${s}`);
    }
}

function analyzeBack(lines) {
    if(val('f520')) return;
    const cleanLines = lines.filter(l => {
        const t = l.text.trim();
        if(t.length < 15 || t.includes('ISBN')) return false;
        return (t.replace(/[a-zA-Z0-9\sÃ Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã®Ã¯Ã´Ã¶Ã¹Ã»Ã¼Ã§Ã±ÂªÂº]/g,'').length / t.length) <= 0.3;
    });
    const sum = cleanLines.map(l=>l.text.trim()).join(' ');
    if(sum.length>20) updateField('f520', `$a ${sum}`);
}

// Utils
function formatAuthorName(name) {
    const isAll = /^[A-Z\s\.\-]+$/.test(name);
    let n = isAll ? name.toLowerCase().replace(/(^|\s)\S/g, l=>l.toUpperCase()) : name;
    const p = n.split(' ');
    return p.length>1 ? `${p.pop()}, ${p.join(' ')}` : n;
}
function updateField(id, v, f=false) {
    const el = document.getElementById(id);
    if(f || !el.value) {
        el.value = v;
        el.classList.add('updated'); // è§¸ç™¼ç¶ è‰²é–ƒçˆ
        setTimeout(()=>el.classList.remove('updated'), 1000);
    }
}
function val(id) { return document.getElementById(id).value; }
function copyOne(id) {
    const el = document.getElementById(id);
    navigator.clipboard.writeText(el.value);
    const btn = el.nextElementSibling; btn.textContent='âœ…'; setTimeout(()=>btn.textContent='ğŸ“‹',1000);
}
function copyAll() {
    const f=['f020','f100','f245','f250','f264','f520'];
    const t=f.map(i=>{const v=document.getElementById(i).value; return v?`${i.substring(1)} ## ${v}`:null}).filter(x=>x).join('\n');
    navigator.clipboard.writeText(t).then(()=>{
        const b=document.querySelector('.copy-all-btn'); b.textContent='âœ… å·²è¤‡è£½'; setTimeout(()=>b.textContent='ğŸ“‹ è¤‡è£½å®Œæ•´è¨˜éŒ„',2000);
    });
}
function msg(t, l=false) { document.getElementById('status').textContent = t + (l?' â³':''); }

// ç°¡åŒ–çš„ API å€å¡Š (åŠŸèƒ½èˆ‡ v5 ç›¸åŒï¼Œç‚ºç¯€çœç¯‡å¹…çœç•¥ç´°ç¯€)
async function fetchGoogle(isbn){ try{const r=await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);const j=await r.json();if(j.totalItems>0){const i=j.items[0].volumeInfo;let t=`$a ${i.title}`;if(i.subtitle)t+=` : $b ${i.subtitle}`;updateField('f245',t);if(i.authors)updateField('f100',`$a ${formatAuthorName(i.authors[0])}, $e author.`);let p=`$b ${i.publisher||''}`;if(i.publishedDate)p+=`, $c ${i.publishedDate.substring(0,4)}`;updateField('f264',p);if(i.description)updateField('f520',`$a ${i.description}`);return true;}}catch(e){}return false;}
async function fetchOpenLibrary(isbn){/* ...Same as v4... */ return false;}
async function fetchBnF(isbn){/* ...Same as v4... */ return false;}
async function preprocess(file){return new Promise(r=>{const i=new Image();i.onload=()=>{const c=document.getElementById('cvs');const x=c.getContext('2d');let w=i.width,h=i.height;if(w>1500){let s=1500/w;w*=s;h*=s;}c.width=w;c.height=h;x.drawImage(i,0,0,w,h);const d=x.getImageData(0,0,w,h);for(let k=0;k<d.data.length;k+=4){const g=(d.data[k]+d.data[k+1]+d.data[k+2])/3;d.data[k]=d.data[k+1]=d.data[k+2]=g>120?255:0;}x.putImageData(d,0,0);r(c.toDataURL('image/jpeg'));};i.src=URL.createObjectURL(file);});}
</script>
</body>
</html>
