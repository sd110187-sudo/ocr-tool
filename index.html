<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MARC 21 - Pro Scanner v4</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
:root { --primary: #2563eb; --bg: #f8fafc; --text: #334155; }
body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding-bottom: 80px; }
header { background: white; padding: 16px; font-weight: 800; text-align: center; border-bottom: 1px solid #e2e8f0; position: sticky; top: 0; z-index: 50; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }

/* Mode Switcher */
.controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; padding: 12px; background: white; border-bottom: 1px solid #f1f5f9; }
.mode-btn { padding: 8px; border: 1px solid #cbd5e1; border-radius: 8px; background: white; font-size: 13px; color: #64748b; font-weight: 500; }
.mode-btn.active { background: var(--primary); color: white; border-color: var(--primary); font-weight: 600; }

/* Scanner */
.scan-area { padding: 16px; text-align: center; }
#scanBtn { width: 100%; padding: 16px; background: #0f172a; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); }
#scanBtn:disabled { opacity: 0.7; }
.status { margin-top: 10px; font-size: 13px; color: #64748b; font-weight: 500; min-height: 20px; }

/* MARC Cards */
.card { background: white; margin: 12px 16px; padding: 16px; border-radius: 12px; border: 1px solid #e2e8f0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
.card-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.badge { font-size: 10px; padding: 3px 8px; border-radius: 12px; font-weight: bold; background: #f1f5f9; color: #64748b; }
.badge.google { background: #dcfce7; color: #166534; } /* Green */
.badge.bnf { background: #dbeafe; color: #1e40af; } /* Blue */
.badge.ocr { background: #ffedd5; color: #9a3412; } /* Orange */

/* Input Groups with Copy Button */
.field-group { margin-bottom: 12px; }
.tag-label { display: block; font-family: monospace; font-size: 12px; font-weight: bold; color: #94a3b8; margin-bottom: 4px; }
.input-wrapper { display: flex; gap: 0; }
.input-wrapper input, .input-wrapper textarea {
    flex: 1; padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px 0 0 8px; font-size: 15px; font-family: monospace; -webkit-appearance: none;
}
.input-wrapper textarea { min-height: 60px; resize: vertical; border-radius: 8px 0 0 8px; }
.copy-btn {
    padding: 0 12px; background: #f1f5f9; border: 1px solid #cbd5e1; border-left: none; border-radius: 0 8px 8px 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; transition: background 0.2s;
}
.copy-btn:active { background: #e2e8f0; }

.filled { border-color: #22c55e !important; background: #f0fdf4; }

details { margin: 16px; font-size: 12px; color: #64748b; }
#debug { white-space: pre-wrap; background: #f1f5f9; padding: 10px; border-radius: 8px; overflow-x: scroll; }
</style>
</head>
<body>

<header>MARC 21 Pro Scanner</header>

<div class="controls">
    <button class="mode-btn active" onclick="setMode('copyright')">æ¢ç¢¼/ç‰ˆæ¬Š</button>
    <button class="mode-btn" onclick="setMode('cover')">å°é¢ (ä½ˆå±€)</button>
    <button class="mode-btn" onclick="setMode('back')">å°åº•æ‘˜è¦</button>
</div>

<div class="scan-area">
    <button id="scanBtn" onclick="document.getElementById('fileIn').click()">ğŸ“¸ å•Ÿå‹•ç›¸æ©Ÿ</button>
    <div class="status" id="status">æº–å‚™å°±ç·’ (Googleå„ªå…ˆ)</div>
    <input type="file" id="fileIn" accept="image/*" capture="environment" style="display:none" onchange="process(this)">
</div>

<div class="card">
    <div class="card-head">
        <b>MARC çµæœ</b>
        <span id="srcTag" class="badge">å¾…æƒæ</span>
    </div>
    
    <div class="field-group">
        <span class="tag-label">020 ISBN</span>
        <div class="input-wrapper">
            <input id="f020" placeholder="$a">
            <button class="copy-btn" onclick="copy('f020')">ğŸ“‹</button>
        </div>
    </div>
    
    <div class="field-group">
        <span class="tag-label">100 Author (è‡ªå‹•æ ¼å¼åŒ–)</span>
        <div class="input-wrapper">
            <input id="f100" placeholder="$a Name, $e author.">
            <button class="copy-btn" onclick="copy('f100')">ğŸ“‹</button>
        </div>
    </div>
    
    <div class="field-group">
        <span class="tag-label">245 Title</span>
        <div class="input-wrapper">
            <input id="f245" placeholder="$a Title">
            <button class="copy-btn" onclick="copy('f245')">ğŸ“‹</button>
        </div>
    </div>
    
    <div class="field-group">
        <span class="tag-label">250 Edition</span>
        <div class="input-wrapper">
            <input id="f250" placeholder="$a">
            <button class="copy-btn" onclick="copy('f250')">ğŸ“‹</button>
        </div>
    </div>
    
    <div class="field-group">
        <span class="tag-label">264 Publication</span>
        <div class="input-wrapper">
            <input id="f264" placeholder="$c Year">
            <button class="copy-btn" onclick="copy('f264')">ğŸ“‹</button>
        </div>
    </div>
    
    <div class="field-group">
        <span class="tag-label">520 Abstract (æ¿¾é›œè¨Š)</span>
        <div class="input-wrapper">
            <textarea id="f520" placeholder="$a"></textarea>
            <button class="copy-btn" onclick="copy('f520')">ğŸ“‹</button>
        </div>
    </div>
</div>

<details>
    <summary>åŸå§‹æ–‡å­— (Debug)</summary>
    <div id="debug"></div>
</details>
<canvas id="cvs" style="display:none"></canvas>

<script>
let worker, mode = 'copyright';

(async () => {
    msg('è¼‰å…¥ OCR å¼•æ“ (å¤šèªè¨€)...', true);
    worker = await Tesseract.createWorker('eng+fra+deu+spa+rus');
    msg('ç³»çµ±å°±ç·’');
})();

function setMode(m) {
    mode = m;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    msg(`æ¨¡å¼: ${m}`);
}

async function process(input) {
    if (!input.files[0]) return;
    const file = input.files[0];
    msg('å½±åƒå„ªåŒ–ä¸­...', true);
    
    const imgData = await preprocess(file);
    
    msg('OCR è­˜åˆ¥ä¸­...', true);
    const { data } = await worker.recognize(imgData);
    document.getElementById('debug').textContent = data.text;
    
    await analyze(data);
    input.value = '';
}

async function analyze(data) {
    const text = data.text;
    const lines = data.lines;
    
    // æ¸…æ´— ISBN é›œè¨Š (O->0, I->1)
    const clean = text.replace(/\|/g,'1').replace(/\bO(\d)/g,'0$1').replace(/[-\s]/g,'');
    const isbnMatch = clean.match(/(97[89]\d{10})|(\d{9}[\dX])/);
    
    let found = false;

    // --- ç­–ç•¥ A: API æŸ¥è©¢ (Google -> OpenLib -> BnF) ---
    if (isbnMatch) {
        const isbn = isbnMatch[0];
        fill('f020', `$a ${isbn}`);
        msg(`æŸ¥ ISBN: ${isbn}...`, true);

        // 1. Google Books (å„ªå…ˆ)
        found = await fetchGoogle(isbn);
        
        // 2. Open Library
        if (!found) {
            msg('Google ç„¡è³‡æ–™ï¼ŒæŸ¥ OpenLib...', true);
            found = await fetchOpenLibrary(isbn);
        }

        // 3. BnF (æœ€å¾Œæ‰‹æ®µï¼Œå°ˆæ”»æ³•æ–‡æ›¸)
        if (!found) {
            msg('OpenLib ç„¡è³‡æ–™ï¼ŒæŸ¥ BnF...', true);
            found = await fetchBnF(isbn);
        }
    }

    // --- ç­–ç•¥ B: OCR æ™ºæ…§å¡«å…¥ ---
    if (!found) {
        msg('API ç„¡è³‡æ–™ï¼Œä½¿ç”¨ OCR æ™ºæ…§åˆ†æ');
        setSrc('OCR', 'ocr');
        
        if (mode === 'cover') {
            analyzeCover(lines);
        } else if (mode === 'copyright') {
            analyzeCopyright(text);
        } else if (mode === 'back') {
            analyzeBack(lines);
        }
    } else {
        msg('è³‡æ–™ç²å–æˆåŠŸ');
    }
}

// --- æ ¸å¿ƒï¼šå°é¢åˆ†æèˆ‡å§“åæ ¼å¼åŒ– ---
function analyzeCover(lines) {
    if(!lines.length) return;
    const validLines = lines.filter(l => l.text.trim().length > 2);
    
    // æ‰¾æœ€å¤§å­—é«” (æ›¸å)
    let maxH = 0;
    validLines.forEach(l => { const h = l.bbox.y1 - l.bbox.y0; if(h>maxH) maxH=h; });
    
    // ç¸«åˆæ¨™é¡Œ
    const titleLines = validLines.filter(l => (l.bbox.y1 - l.bbox.y0) > maxH * 0.7);
    const title = titleLines.map(l => l.text.trim()).join(' ');
    if(!val('f245')) fill('f245', `$a ${title}`);
    
    // æ‰¾ä½œè€… (æ¨™é¡Œä¸Šæ–¹)
    if(!val('f100') && titleLines.length > 0) {
        const topY = titleLines[0].bbox.y0;
        const authorLines = validLines.filter(l => l.bbox.y1 < topY && !/\d/.test(l.text));
        
        if(authorLines.length > 0) {
            // å–æœ€é è¿‘æ¨™é¡Œçš„é‚£ä¸€è¡Œ
            const rawName = authorLines[authorLines.length-1].text.trim();
            // æ ¼å¼åŒ–å§“å (è½‰æ›å¤§å°å¯« + åè½‰)
            const fmtName = formatAuthorName(rawName);
            fill('f100', `$a ${fmtName}, $e author.`);
        }
    }
}

// --- æ ¸å¿ƒï¼šå§“åè™•ç†é‚è¼¯ ---
function formatAuthorName(name) {
    // 1. è™•ç†å…¨å¤§å¯« (ASMA MHALLA -> Asma Mhalla)
    // æª¢æ¸¬æ˜¯å¦å…¨ç‚ºå¤§å¯«å­—æ¯ (å¿½ç•¥ç©ºæ ¼å’Œç¬¦è™Ÿ)
    const isAllCaps = /^[A-Z\s\.\-]+$/.test(name);
    
    let processedName = name;
    if (isAllCaps) {
        processedName = name.toLowerCase().replace(/(^|\s)\S/g, l => l.toUpperCase());
    }
    
    // 2. è™•ç†åè½‰ (Asma Mhalla -> Mhalla, Asma)
    // ç°¡å–®é‚è¼¯ï¼šå‡è¨­æœ€å¾Œä¸€å€‹è©æ˜¯å§“æ°
    const parts = processedName.split(' ');
    if (parts.length > 1) {
        const lastName = parts.pop();
        return `${lastName}, ${parts.join(' ')}`;
    }
    return processedName;
}

// --- æ ¸å¿ƒï¼šå°åº•æ‘˜è¦éæ¿¾ (å»é™¤äº‚ç¢¼) ---
function analyzeBack(lines) {
    if(val('f520')) return;
    
    // éæ¿¾é‚è¼¯ï¼š
    // 1. å»é™¤å¤ªçŸ­çš„è¡Œ
    // 2. å»é™¤åŒ…å« ISBN çš„è¡Œ
    // 3. å»é™¤ã€Œéå­—æ¯å­—å…ƒã€æ¯”ä¾‹éé«˜çš„è¡Œ (é˜²æ­¢äº‚ç¢¼)
    const cleanLines = lines.filter(l => {
        const t = l.text.trim();
        if(t.length < 15) return false; // å¤ªçŸ­
        if(t.includes('ISBN') || t.includes('978-')) return false; // æ¢ç¢¼
        
        // è¨ˆç®—éå­—æ¯ç¬¦è™Ÿæ¯”ä¾‹
        const invalidChars = t.replace(/[a-zA-Z0-9\sÃ Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã®Ã¯Ã´Ã¶Ã¹Ã»Ã¼Ã§Ã±]/g, '').length;
        if ((invalidChars / t.length) > 0.3) return false; // è¶…é 30% æ˜¯äº‚ç¢¼å‰‡ä¸Ÿæ£„
        
        return true;
    });

    const summary = cleanLines.map(l => l.text.trim()).join(' ');
    if(summary.length > 20) {
        fill('f520', `$a ${summary}`);
    }
}

function analyzeCopyright(text) {
    const year = text.match(/\b(19|20)\d{2}\b/);
    if(year && !val('f264')) fill('f264', `$c ${year[0]}`);
    
    // æ‰¾ç‰ˆæ¬¡
    const ed = text.match(/(\d+(st|nd|rd|th|e|eme)|Prem|Deux|Trois|First|Second)\s+(ed|aufl)/i);
    if(ed && !val('f250')) fill('f250', `$a ${ed[0]}`);
}

// --- API Functions (é †åº: Google -> OpenLib -> BnF) ---

async function fetchGoogle(isbn) {
    try {
        const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
        const json = await res.json();
        if (json.totalItems > 0) {
            const i = json.items[0].volumeInfo;
            setSrc('Google Books', 'google');
            fill('f245', `$a ${i.title}`);
            if(i.authors) fill('f100', `$a ${formatAuthorName(i.authors[0])}, $e author.`);
            fill('f264', `$b ${i.publisher||''}, $c ${i.publishedDate?.slice(0,4)||''}`);
            if(i.description) fill('f520', `$a ${i.description}`);
            return true;
        }
    } catch(e){}
    return false;
}

async function fetchOpenLibrary(isbn) {
    try {
        const res = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&jscmd=details&format=json`);
        const json = await res.json();
        const key = `ISBN:${isbn}`;
        if (json[key]) {
            const d = json[key].details;
            setSrc('Open Library', 'ocr');
            fill('f245', `$a ${d.title}`);
            if(d.authors) fill('f100', `$a ${formatAuthorName(d.authors[0].name)}, $e author.`);
            fill('f264', `$c ${d.publish_date} : $b ${d.publishers?.[0]}`);
            return true;
        }
    } catch(e){}
    return false;
}

async function fetchBnF(isbn) {
    try {
        // BnF SRU API
        const url = `https://catalogue.bnf.fr/api/SRU?version=1.2&operation=searchRetrieve&query=bib.isbn%20adj%20%22${isbn}%22&recordSchema=dublincore`;
        const res = await fetch(url);
        const str = await res.text();
        if (str.includes('<dc:title>')) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(str, "text/xml");
            
            const title = xml.querySelector('title')?.textContent || '';
            let creator = xml.querySelector('creator')?.textContent || '';
            const date = xml.querySelector('date')?.textContent || '';
            const pub = xml.querySelector('publisher')?.textContent || '';
            
            // BnF çš„åå­—é€šå¸¸å·²ç¶“æ˜¯æ ¼å¼åŒ–å¥½çš„ï¼Œæˆ–è€…æ˜¯ "Mhalla, Asma" æ ¼å¼ï¼Œé€™è£¡åšå€‹ç°¡å–®æª¢æŸ¥
            if(creator && !creator.includes(',')) creator = formatAuthorName(creator);

            setSrc('BnF (æ³•)', 'bnf');
            fill('f245', `$a ${title}`);
            if(creator) fill('f100', `$a ${creator}, $e author.`);
            fill('f264', `$a [France] : $b ${pub}, $c ${date}`);
            return true;
        }
    } catch(e) {}
    return false;
}

// --- Utilities ---
function copy(id) {
    const el = document.getElementById(id);
    el.select();
    navigator.clipboard.writeText(el.value).then(() => {
        const btn = el.nextElementSibling;
        const original = btn.textContent;
        btn.textContent = 'âœ…';
        setTimeout(() => btn.textContent = original, 1000);
    });
}

function preprocess(file) {
    return new Promise(r => {
        const img = new Image();
        img.onload = () => {
            const c = document.getElementById('cvs');
            const ctx = c.getContext('2d');
            let w = img.width, h = img.height;
            if(w>1500) { let s=1500/w; w*=s; h*=s; }
            c.width=w; c.height=h;
            ctx.drawImage(img,0,0,w,h);
            const d = ctx.getImageData(0,0,w,h);
            for(let i=0;i<d.data.length;i+=4){
                const avg = (d.data[i]+d.data[i+1]+d.data[i+2])/3;
                const v = avg > 120 ? 255 : 0;
                d.data[i]=d.data[i+1]=d.data[i+2]=v;
            }
            ctx.putImageData(d,0,0);
            r(c.toDataURL('image/jpeg'));
        };
        img.src = URL.createObjectURL(file);
    });
}

function fill(id, val) { 
    const el = document.getElementById(id); 
    if(!el.value) { // åªæœ‰ç•¶æ¬„ä½æ˜¯ç©ºçš„æ™‚å€™æ‰å¡«å…¥ (é¿å…è¦†è“‹æ‰‹å‹•ä¿®æ”¹)
        el.value = val; 
        el.classList.add('filled'); 
        setTimeout(()=>el.classList.remove('filled'), 1000);
    }
}
function val(id) { return document.getElementById(id).value; }
function setSrc(n, t) { const e=document.getElementById('srcTag'); e.textContent=n; e.className=`badge ${t}`; }
function msg(t, l=false) { document.getElementById('status').textContent = t + (l?' â³':''); }
</script>
</body>
</html>
