<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MARC 21 - BnF & Smart Stitch</title>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
:root { --primary: #0055a4; /* BnF Blue */ --bg: #f4f6f8; }
body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); margin: 0; padding-bottom: 80px; }
header { background: white; padding: 16px; font-weight: 800; text-align: center; border-bottom: 1px solid #ddd; position: sticky; top: 0; z-index: 50; }

.controls { display: flex; gap: 8px; padding: 12px; background: white; overflow-x: auto; }
.mode-btn { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 20px; background: white; font-size: 13px; color: #555; white-space: nowrap; }
.mode-btn.active { background: var(--primary); color: white; border-color: var(--primary); font-weight: 600; }

.scan-area { padding: 16px; text-align: center; }
#scanBtn { width: 100%; padding: 16px; background: #2c3e50; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.status { margin-top: 10px; font-size: 13px; color: #666; font-weight: 500; min-height: 20px; }

/* Result Card */
.card { background: white; margin: 12px 16px; padding: 16px; border-radius: 12px; border: 1px solid #eee; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
.card-head { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.badge { font-size: 10px; padding: 4px 8px; border-radius: 4px; background: #eee; color: #666; font-weight: bold; }
.badge.bnf { background: #e3f2fd; color: #0277bd; }
.badge.google { background: #e8f5e9; color: #2e7d32; }
.badge.ocr { background: #fff8e1; color: #f57f17; }

.field { margin-bottom: 10px; display: flex; align-items: center; }
.tag { width: 40px; font-family: monospace; font-weight: bold; color: #888; font-size: 14px; }
input, textarea { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 15px; width: 100%; font-family: inherit; }
textarea { min-height: 70px; resize: vertical; }
.filled { animation: glow 1s ease-out; border-color: #4caf50; }
@keyframes glow { 0% { background-color: #dcedc8; } 100% { background-color: white; } }

details { margin: 16px; font-size: 12px; color: #666; }
#debug { white-space: pre-wrap; background: #eee; padding: 10px; border-radius: 8px; }
</style>
</head>
<body>

<header>MARC 21 - æ³•æ–‡/è¥¿æ–‡å°ˆç”¨ç‰ˆ</header>

<div class="controls">
    <button class="mode-btn active" onclick="setMode('copyright')">æ¢ç¢¼/ç‰ˆæ¬Šé </button>
    <button class="mode-btn" onclick="setMode('cover')">å°é¢ (æ™ºæ…§æ‹¼æ¥)</button>
    <button class="mode-btn" onclick="setMode('back')">å°åº•æ‘˜è¦</button>
</div>

<div class="scan-area">
    <button id="scanBtn" onclick="document.getElementById('fileIn').click()">ğŸ“¸ å•Ÿå‹•ç›¸æ©Ÿ</button>
    <div class="status" id="status">æº–å‚™å°±ç·’ (BnF/Google/OpenAlex)</div>
    <input type="file" id="fileIn" accept="image/*" capture="environment" style="display:none" onchange="process(this)">
</div>

<div class="card">
    <div class="card-head">
        <b>MARC è³‡æ–™</b>
        <span id="srcTag" class="badge">ç­‰å¾…æƒæ</span>
    </div>
    <div class="field"><div class="tag">020</div><input id="f020" placeholder="$a ISBN"></div>
    <div class="field"><div class="tag">100</div><input id="f100" placeholder="$a Author"></div>
    <div class="field"><div class="tag">245</div><input id="f245" placeholder="$a Title"></div>
    <div class="field"><div class="tag">250</div><input id="f250" placeholder="$a Edition"></div>
    <div class="field"><div class="tag">264</div><input id="f264" placeholder="$c Year"></div>
    <div class="field"><div class="tag">520</div><textarea id="f520" placeholder="$a Abstract"></textarea></div>
</div>

<details>
    <summary>OCR åŸå§‹è³‡æ–™ (Debug)</summary>
    <div id="debug"></div>
</details>
<canvas id="cvs" style="display:none"></canvas>

<script>
let worker, mode = 'copyright';

// åˆå§‹åŒ–
(async () => {
    msg('è¼‰å…¥ OCR å¼•æ“ (Fra/Eng/Deu)...', true);
    // é‡è¦ï¼šè¼‰å…¥æ³•æ–‡(fra)èªè¨€åŒ…ä»¥æ”¯æ´é‡éŸ³ç¬¦è™Ÿ
    worker = await Tesseract.createWorker('eng+fra+deu+spa');
    msg('ç³»çµ±å°±ç·’');
})();

function setMode(m) {
    mode = m;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    event.target.classList.add('active');
    msg(`æ¨¡å¼: ${m}`);
}

async function process(input) {
    if (!input.files[0]) return;
    const file = input.files[0];
    msg('å½±åƒå„ªåŒ–è™•ç†...', true);
    
    // 1. å½±åƒäºŒå€¼åŒ–è™•ç† (åŠ å¼·å°æ¯”)
    const imgData = await preprocess(file);
    
    msg('OCR è¾¨è­˜èˆ‡ä½ˆå±€åˆ†æ...', true);
    // 2. åŸ·è¡Œ OCR
    const { data } = await worker.recognize(imgData);
    document.getElementById('debug').textContent = data.text;
    
    // 3. åŸ·è¡Œåˆ†æ
    await analyze(data);
    input.value = '';
}

async function analyze(data) {
    const text = data.text;
    const lines = data.lines; // å–å¾—è¡Œè³‡è¨Š
    
    // ISBN æƒæ
    const cleanText = text.replace(/\s+/g, '').replace(/-/g, '');
    const isbnMatch = cleanText.match(/(97[89]\d{10})|(\d{9}[\dX])/);
    
    let foundApi = false;

    // --- ç­–ç•¥ A: API æŸ¥è©¢ (BnF å„ªå…ˆ -> Google -> OpenLibrary) ---
    if (isbnMatch) {
        const isbn = isbnMatch[0];
        fill('f020', `$a ${isbn}`);
        msg(`åµæ¸¬åˆ° ISBN ${isbn}ï¼ŒæŸ¥è©¢ BnF...`, true);

        // 1. æŸ¥æ³•åœ‹åœ‹å®¶åœ–æ›¸é¤¨ (BnF) - å°æ³•æ–‡æ›¸æœ€å¼·
        foundApi = await fetchBnF(isbn);
        
        // 2. æŸ¥ Google Books
        if (!foundApi) {
            msg('BnF ç„¡è³‡æ–™ï¼ŒæŸ¥ Google Books...', true);
            foundApi = await fetchGoogle(isbn);
        }
        
        // 3. æŸ¥ OpenLibrary
        if (!foundApi) {
            msg('Google ç„¡è³‡æ–™ï¼ŒæŸ¥ OpenLibrary...', true);
            foundApi = await fetchOpenLibrary(isbn);
        }
    }

    // --- ç­–ç•¥ B: OCR æ™ºæ…§å¡«å…¥ (ç•¶ API å¤±æ•—æ™‚) ---
    if (!foundApi) {
        msg('API ç„¡è³‡æ–™ï¼Œå•Ÿå‹• OCR æ™ºæ…§åˆ†æ');
        setSource('OCR æ™ºæ…§åˆ†æ', 'ocr');
        
        if (mode === 'cover') {
            analyzeCoverSmartly(lines); // å‘¼å«æ–°çš„ç¸«åˆæ¼”ç®—æ³•
        } else if (mode === 'copyright') {
            analyzeCopyright(text);
        } else if (mode === 'back') {
            if(!val('f520')) fill('f520', '$a ' + text.replace(/\n/g, ' ').slice(0, 600));
        }
    } else {
        msg('è³‡æ–™ç²å–æˆåŠŸ');
    }
}

// --- æ ¸å¿ƒæ”¹é€² 1: å¤šè¡Œæ¨™é¡Œç¸«åˆæ¼”ç®—æ³• (Title Stitching) ---
function analyzeCoverSmartly(lines) {
    if (!lines || lines.length === 0) return;

    // 1. éæ¿¾é›œè¨Š (å¤ªçŸ­çš„è¡Œ)
    const validLines = lines.filter(l => l.text.trim().length > 2);
    
    // 2. æ‰¾å‡ºã€Œæœ€å¤§å­—é«”ã€çš„é«˜åº¦
    let maxH = 0;
    validLines.forEach(l => {
        const h = l.bbox.y1 - l.bbox.y0;
        if(h > maxH) maxH = h;
    });

    // 3. æ‰¾å‡ºæ‰€æœ‰ã€Œå¤§æ¨™é¡Œè¡Œã€ (é«˜åº¦å¤§æ–¼æœ€å¤§é«˜åº¦çš„ 70%)
    // ä¸¦ä¾ç…§ Y è»¸åº§æ¨™æ’åº (ç”±ä¸Šè€Œä¸‹)
    const titleLines = validLines
        .filter(l => (l.bbox.y1 - l.bbox.y0) > maxH * 0.7)
        .sort((a,b) => a.bbox.y0 - b.bbox.y0);

    // 4. ç¸«åˆæ¨™é¡Œ (é€™æ˜¯è§£æ±º "de la pensÃ©e" æ–·è£‚çš„é—œéµ)
    if (titleLines.length > 0) {
        // å°‡æ‰€æœ‰å¤§å­—é«”è¡Œåˆä½µ
        const fullTitle = titleLines.map(l => l.text.trim()).join(' ');
        if (!val('f245')) fill('f245', `$a ${fullTitle}`);
        
        // 5. æ‰¾ä½œè€… (æ’é™¤æ‰æ¨™é¡Œè¡Œï¼Œæ‰¾å‰©ä¸‹ä½æ–¼æ¨™é¡Œä¸Šæ–¹çš„è¡Œ)
        // å‡è¨­æ¨™é¡Œç¬¬ä¸€è¡Œçš„ Y åº§æ¨™æ˜¯ threshold
        const titleTopY = titleLines[0].bbox.y0;
        
        // æ‰¾æ¨™é¡Œä¸Šæ–¹çš„è¡Œ
        const authorCand = validLines.filter(l => 
            l.bbox.y1 < titleTopY && // åœ¨æ¨™é¡Œä¸Šé¢
            !/\d/.test(l.text) &&    // æ²’æœ‰æ•¸å­—
            l.text.length > 3
        );
        
        if (authorCand.length > 0 && !val('f100')) {
            // å–æœ€æ¥è¿‘æ¨™é¡Œçš„é‚£ä¸€è¡Œ (é€šå¸¸æ˜¯ä½œè€…)
            const author = authorCand[authorCand.length-1].text.trim();
            fill('f100', `$a ${author}, $e author.`);
        }
    }

    // 6. æ‰¾ç‰ˆæ¬¡ (ä¸åˆ†ä½ç½®ï¼Œå…¨é æœå°‹)
    findEditionRobust(validLines.map(l=>l.text).join('\n'));
}

function analyzeCopyright(text) {
    // æ‰¾å¹´ä»½
    const year = text.match(/\b(19|20)\d{2}\b/);
    if(year && !val('f264')) fill('f264', `$c ${year[0]}`);
    findEditionRobust(text);
}

// --- æ ¸å¿ƒæ”¹é€² 2: æ¨¡ç³Šç‰ˆæ¬¡åµæ¸¬ (Fuzzy Edition) ---
function findEditionRobust(text) {
    if (val('f250')) return;

    // ç§»é™¤é‡éŸ³ç¬¦è™Ÿä¸¦è½‰å°å¯«ï¼Œè§£æ±º 'Ã©dition' vs 'edition' å•é¡Œ
    const norm = text.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
    
    // å»ºç«‹é—œéµå­—æ˜ å°„ (æ³•/è‹±/å¾·)
    const keyMap = {
        'premiere': '1st', 'first': '1st',
        'deuxieme': '2nd', 'second': '2nd',
        'troisieme': '3rd', 'third': '3rd', '3e': '3rd',
        'quatrieme': '4th', 'fourth': '4th'
    };

    // æœå°‹ edition/auflage é—œéµå­—
    // Regex è§£é‡‹ï¼šæ‰¾ (æ•¸å­—+e/th) æˆ– (æ–‡å­—æ•¸å­—) å¾Œé¢è·Ÿè‘— edit/aufl
    const regex = /(\b\d+(e|th|rd|nd|st)\b|\bpremiere\b|\bdeuxieme\b|\btroisieme\b|\bquatrieme\b|\bfirst\b|\bsecond\b|\bthird\b).*?(edit|aufl)/i;
    
    const match = norm.match(regex);
    if (match) {
        // å¦‚æœæ‰¾åˆ°ï¼Œå˜—è©¦å›é ­å»åŸå§‹ text æŠ“é‚£ä¸€è¡Œ
        // é€™è£¡ç°¡å–®è™•ç†ï¼šç›´æ¥çµ„æ§‹æ¨™æº–æ ¼å¼
        let ver = match[1]; // æŠ“åˆ°çš„ç‰ˆæœ¬è© (å¦‚ troisieme)
        if(keyMap[ver]) ver = keyMap[ver]; // è½‰æˆ 3rd (å¯é¸)
        
        fill('f250', `$a ${match[0]} (Detected)`); // å¡«å…¥åµæ¸¬åˆ°çš„å­—ä¸²
    }
}

// --- API: æ³•åœ‹åœ‹å®¶åœ–æ›¸é¤¨ (BnF) SRU ---
async function fetchBnF(isbn) {
    try {
        // BnF çš„å…è²» SRU API
        const url = `https://catalogue.bnf.fr/api/SRU?version=1.2&operation=searchRetrieve&query=bib.isbn%20adj%20%22${isbn}%22&recordSchema=dublincore`;
        const res = await fetch(url);
        const str = await res.text();
        
        // ç°¡å–®è§£æ XML
        if (str.includes('<dc:title>')) {
            const parser = new DOMParser();
            const xml = parser.parseFromString(str, "text/xml");
            
            const title = xml.querySelector('title')?.textContent || '';
            const creator = xml.querySelector('creator')?.textContent || '';
            const date = xml.querySelector('date')?.textContent || '';
            const publisher = xml.querySelector('publisher')?.textContent || '';
            
            setSource('BnF æ³•åœ‹åœ‹å®¶åœ–æ›¸é¤¨', 'bnf');
            fill('f245', `$a ${title}`);
            if(creator) fill('f100', `$a ${creator}, $e author.`);
            fill('f264', `$a [France] : $b ${publisher}, $c ${date}`);
            return true;
        }
    } catch(e) { console.error(e); }
    return false;
}

async function fetchGoogle(isbn) {
    try {
        const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`);
        const json = await res.json();
        if (json.totalItems > 0) {
            const i = json.items[0].volumeInfo;
            setSource('Google Books', 'google');
            fill('f245', `$a ${i.title}`);
            if(i.authors) fill('f100', `$a ${i.authors[0]}, $e author.`);
            fill('f264', `$b ${i.publisher||''}, $c ${i.publishedDate?.slice(0,4)||''}`);
            return true;
        }
    } catch(e){}
    return false;
}

async function fetchOpenLibrary(isbn) {
    try {
        const res = await fetch(`https://openlibrary.org/api/books?bibkeys=ISBN:${isbn}&jscmd=details&format=json`);
        const json = await res.json();
        const key = `ISBN:${isbn}`;
        if (json[key]) {
            const d = json[key].details;
            setSource('Open Library', 'ocr');
            fill('f245', `$a ${d.title}`);
            if(d.authors) fill('f100', `$a ${d.authors[0].name}, $e author.`);
            fill('f264', `$c ${d.publish_date} : $b ${d.publishers?.[0]}`);
            return true;
        }
    } catch(e){}
    return false;
}

// Utils
function preprocess(file) {
    return new Promise(r => {
        const img = new Image();
        img.onload = () => {
            const c = document.getElementById('cvs');
            const ctx = c.getContext('2d');
            let w = img.width, h = img.height;
            if(w>1500) { let s=1500/w; w*=s; h*=s; } // Resize
            c.width=w; c.height=h;
            ctx.drawImage(img,0,0,w,h);
            
            // ç°¡å–®äºŒå€¼åŒ–
            const d = ctx.getImageData(0,0,w,h);
            const data = d.data;
            for(let i=0; i<data.length; i+=4) {
                const avg = (data[i]+data[i+1]+data[i+2])/3;
                const v = avg > 120 ? 255 : 0; // Threshold
                data[i]=data[i+1]=data[i+2]=v;
            }
            ctx.putImageData(d,0,0);
            r(c.toDataURL('image/jpeg'));
        };
        img.src = URL.createObjectURL(file);
    });
}

function fill(id, val) { 
    const el = document.getElementById(id); 
    el.value = val; 
    el.classList.add('filled'); 
    setTimeout(()=>el.classList.remove('filled'), 1000);
}
function val(id) { return document.getElementById(id).value; }
function setSource(name, type) {
    const el = document.getElementById('srcTag');
    el.textContent = name;
    el.className = `badge ${type}`;
}
function msg(t, l=false) { 
    document.getElementById('status').textContent = t + (l?' â³':''); 
}
</script>
</body>
</html>
